#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.root_command
root_command() {
  # :src/root_command.sh
  requires curl
  requires git
  requires jq
  
  token="${GITHUB_TOKEN}"
  if [[ ! "${GITHUB_TOKEN}" ]]; then
    token="${args[token]}"
  fi
  
  if [[ ! "${token}" ]]; then
    token=$(git config github.token)
  fi
  
  if [[ ! "${token}" ]]; then
    err 'you must specifiy a valid token by defining a GITHUB_TOKEN env, using the --token flag or setting it in your global git config.'
  fi
  
  CURL_OPTS=
  # if [[ "${args[--public]}" ]]; then
  #   CURL_OPTS+='--data-urlencode public=true '
  # else
  #   CURL_OPTS+='--data-urlencode public=false '
  # fi
  
  payload=$(
    jq -n \
      --arg description "description" \
      --arg name        "${args[--name]}"   \
      --arg extension   "${args[--extension]}" \
      --arg content     "derp"        \
      --arg public      "true"       \
      '{
        description: $description, 
        public: $public,
        files: {
          "\($name).\($extension)": {
            content: $content
          }
        }
      }'
  )
  
  curl -s -X POST https://api.github.com/gists \
    -H "Accept: application/vnd.github.v3+json" \
    -H "Authorization: token ${token}" \
    ${CURL_OPTS} \
    -d "${payload}" | jq -r '.html_url'
  
  #   LOCATION=$(cat $RESPONSE_FILE|sed -ne '/Location/p'|cut -f2- -d:|tr -d ' ')
  #   log "* Gist location:"
  #   echo "$LOCATION"
}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
baste_usage() {
  if [[ -n $long_usage ]]; then
    printf "baste - A paste bin tool written in Bash.\n"
    echo 
  else
    printf "baste - A paste bin tool written in Bash.\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  baste [options]\n"
  printf "  baste --help | -h\n"
  printf "  baste --version | -v\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --description, -d DESCRIPTION"
    printf "    A brief description of your Gist.\n"
    echo
    
    # :flag.usage
    echo "  --name, -n NAME"
    printf "    The file name of your Gist.\n"
    printf "    Default: gistfile1\n"
    echo
    
    # :flag.usage
    echo "  --content, -c CONTENT"
    printf "    The content of your Gist.\n"
    echo
    
    # :flag.usage
    echo "  --public, -p"
    printf "    Determines whether your Gist will be public or private.\n"
    echo
    
    # :flag.usage
    echo "  --clipboard, --clip"
    printf "    Attempts to use the latest entry in your local clipboard as content for your\n    Gist. If using MacOS, an attempt to use pbpaste will be made. Otherwise,\n    xsel will be used.\n"
    echo
    
    # :flag.usage
    echo "  --file, -f FILE"
    printf "    A path to the file to upload to Gist.\n"
    echo
    
    # :flag.usage
    echo "  --extension, -e EXTENSION"
    printf "    The file extension of the Gist. If the path used in --file contains a file\n    extension, baste will use that instead.\n"
    printf "    Default: txt\n"
    echo
    
    # :flag.usage
    echo "  --token, -t TOKEN"
    printf "    Explicitly specific a personal developer token as an alternative to using\n    the GITHUB_TOKEN environmental variable.\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"
    
    # :environment_variable.usage
    echo "  GITHUB_TOKEN"
    printf "    A personal developer token associated with your Github account. You can\n    easily create a new one in the \"Developer Settings\" page under your\n    account's settings. The only permission scope you will need is \"gist\" in\n    order to create new Gists.\n"
    echo
    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  base --file /path/to/file.txt\n"
    printf "  baste --content '... code ...'\n"
    printf "  baste --name 'README.md' --content '# My Readme' --public\n"
    printf "  cat /path/to/file | baste\n"
    printf "  baste --clipboard\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# :src/lib/colors.sh
# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
# 
#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# :src/lib/err_function.sh
err() {
  echo -e "$(red_bold [ERR]) ${1}" >&2
  exit 1
}

# :src/lib/inf_function.sh
inf() {
  echo -e "$(green [INF]) ${1}" >&2
}

# :src/lib/requires_function.sh
requires() {
  command -v "${1}" &> /dev/null || err "baste requires '${1}'"
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    baste_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="root"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --description | -d )
      if [[ $2 ]]; then
        args[--description]="$2"
        shift
        shift
      else
        printf "%s\n" "--description requires an argument: --description, -d DESCRIPTION"
        exit 1
      fi
      ;;
  
    # :flag.case
    --name | -n )
      if [[ $2 ]]; then
        args[--name]="$2"
        shift
        shift
      else
        printf "%s\n" "--name requires an argument: --name, -n NAME"
        exit 1
      fi
      ;;
  
    # :flag.case
    --content | -c )
      if [[ $2 ]]; then
        args[--content]="$2"
        shift
        shift
      else
        printf "%s\n" "--content requires an argument: --content, -c CONTENT"
        exit 1
      fi
      ;;
  
    # :flag.case
    --public | -p )
      args[--public]=1
      shift
      ;;
  
    # :flag.case
    --clipboard | --clip )
      args[--clipboard]=1
      shift
      ;;
  
    # :flag.case
    --file | -f )
      if [[ $2 ]]; then
        args[--file]="$2"
        shift
        shift
      else
        printf "%s\n" "--file requires an argument: --file, -f FILE"
        exit 1
      fi
      ;;
  
    # :flag.case
    --extension | -e )
      if [[ $2 ]]; then
        args[--extension]="$2"
        shift
        shift
      else
        printf "%s\n" "--extension requires an argument: --extension, -e EXTENSION"
        exit 1
      fi
      ;;
  
    # :flag.case
    --token | -t )
      if [[ $2 ]]; then
        args[--token]="$2"
        shift
        shift
      else
        printf "%s\n" "--token requires an argument: --token, -t TOKEN"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--name]} ]] || args[--name]="gistfile1"
  [[ -n ${args[--extension]} ]] || args[--extension]="txt"
  # :command.whitelist_filter
}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
    printf "bash version 4 or higher is required\n"
    exit 1
  fi

  # :src/initialize.sh
  # Code here runs inside the initialize() function
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  # CONFIG_FILE=settings.ini
  #
  # Feel free to empty (but not delete) this file.
}

# :command.run
run() {
  declare -A args
  declare -a other_args
  declare -a input
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
